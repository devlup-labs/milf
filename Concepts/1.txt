PHASE 1: SETUP & CONFIGURATION
har function ke liye alag define nahi kar sakte 


You can't run it "directly" because WASM is a separate virtual machine
You have to set up the environment (blueprint + machine + memory) before you can push the button. 
The "Universal Dispatcher" is simply a way to push any button on that machine without rebuilding the engine every time.



Does the Load -> Instantiate -> Invoke cycle make sense to you? It's like putting a DVD into a player—you can't just look at the disc to see the movie; you need the player to read it and output the signal.

universal dispatcher : 
  Instead of hardcoding "add", you pass the function name as a string and 
  arguments as an array from Java. The C++ code uses:
    - wasm_runtime_lookup_function(module_inst, jni_string_name)
    - uint32_t argv[] = jni_array_args;
✓ Check JNI/stub implementations 

  → **Why not "Direct" execution?
    1. **The Sandbox:** WASM is isolated. It cannot see your phone's RAM. 
    2. **Memory Marshalling:** Host (Java) data must be copied into WASM memory. something like json 
        JSON only carries data, not memory semantics. concurrent access to memory 

    3. **Runtime Lifecycle:** You must **Load** (parse), **Instantiate** (setup memory/stack), 
       and then **Invoke** (call the export) in sequence.
  → Located in native-lib.cpp with corresponding declarations in WasmService.kt

  → **Generic Dispatcher Approach:** 
    Instead of writing new C++ functions for every task, we use a single 
    Universal JNI function that takes a `String functionName` and `Array arguments`.
    This maps host data to WASM machine types dynamically.
✓ Check CMake configuration
  → CMake is the build system that compiles native C/C++ code for Android
  → Ensures proper linking of WAMR libraries and native-lib.cpp
  → Configured in android/app/src /main/cpp/CMakeLists.txt

✓ Configure WAMR build
  → WAMR (WebAssembly Micro Runtime) needs specific build flags
  → Execution-only mode (no compilation/AOT features needed for basic runtime)
  → Fast interpreter mode enabled for better performance

✓ Ensure WAMR submodule or source is present
  → WAMR source code should be included as a Git submodule or copied directly
  → Located in: android/app/src/main/cpp/wamr/
  → Contains core runtime, interpreter, and memory management

✓ Configure CMakeLists.txt for execution-only build
  → Set WASM_ENABLE_INTERP=1 (enable interpreter)
  → Set WASM_ENABLE_FAST_INTERP=1 (enable fast interpreter)
  → Disable unnecessary features (AOT, JIT) to reduce binary size

✓ Implement Native/JNI Bridge
  → C++ function to instantiate WASM module from byte array
  → C++ function to execute WASM main/exported functions
  → Memory management for WASM runtime instance and module instance

✓ Implement Android Service for Sandbox
  → Verify isolatedProcess service setup (security isolation)
  → IPC mechanism (AIDL) for sending WASM bytes and receiving output ☑️

✓ Flutter Side Implementation
  → File picker to select WASM file from device storage
  → MethodChannel to send file bytes to Android Native layer ☑️



================================================================================
PHASE 2: PROJECT PURPOSE & ARCHITECTURE
================================================================================

PROJECT GOALS:
--------------------------------------------------------------------------------
1. Code Storage & Management
   → Repository holds the complete WAMR integration codebase
   → Version control for native C++, Kotlin, and Flutter components
   → Modular architecture for easy maintenance and updates

2. Multi-Language WASM Execution
   → Execute WebAssembly modules compiled from different languages:
     • Rust → WASM
     • C/C++ → WASM
     • AssemblyScript → WASM
     • Go (TinyGo) → WASM
   → Language-agnostic execution: WAMR doesn't care about source language
   → Only requirement: valid WASM bytecode format

3. Testing & Validation
   → Test WASM modules with different complexity levels
   → Validate memory limits and execution timeouts
   → Ensure sandbox isolation prevents crashes from affecting main app

PHASE 3: CORE IMPLEMENTATION DETAILS
================================================================================

WASM EXECUTION FLOW:
--------------------------------------------------------------------------------
User selects .wasm file → Flutter UI → MethodChannel → Android Native
→ WasmService (isolated process) → native-lib.cpp → WAMR Runtime → Execution


WAMR INTEGRATION:
--------------------------------------------------------------------------------
    create CMakeLists.txt -- to compile wsamr core (iwasmn), (native-lib.cpp)
    native-lib.c has the basic code to run the wasm module
    meta-data type: Information about the Wasm file (name, size, or version) 
    sent along with the bytes to help the service manage the execution.

Android Service Isolation : 
    WasmServiceInterface.aidl for IPC -- Basic Byte Array type laoding 
    
    
Main Activity : method channel took file as the input and send it to the native \
        Binder Connection is used -- for isolation 
WasmService : The bodygaurd, isolateProcess = true 
        load native-lib 
        runWasm : 
        implementation of IPC 

The Engine : native-lib.cpp 
    the translator convert java to C, run WAMR and convert the result back 
    - memory allocation,
    - load wasm byte from java array 
    - load module 
    - lookup for start main 
    - example input: if the WASM function requires an integer, the native 
      code provides it (e.g., hardcoded '2' for initial testing).
    - send back to java queue: Results are queued so the main thread doesn't 
      freeze while waiting for the WASM execution to finish.
    
- CMakeLists.txt: 
    Tells the build system how to compile `native-lib.cpp` using the 
    **Android NDK Clang compiler**. It handles cross-compilation for 
    different phone architectures (arm64, x86_64, etc.).



I will not able to run the wasm file directly from the java code -- 